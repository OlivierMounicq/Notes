## 2/ Refactoring to an immutable architecture

### 2.1/ Why does Immutability matter ?

- Increaed readability  
- A single place for validating invariants  
- Automatic thread safe 

### 2.2/ Temporal coupling

```cs
public class CustomerService
{
  private Address _address;
  private Customer _customer;
  
  public void Process(string customerName, string customerAddress)
  {
    CreateAddress();
    CreateCustomer();
    SaveCustomer();
  }

  private void CreateAdress(string addressString)
  {
    _address = new Address(addressString);    
  }
  
  private void CreateCustomer(string name)
  {
    _customer = new Customer(name, _adress);
  }
  
  private void SaveCustomer()
  {
    var repository = new Repository();
    repository.Save(_customer);
  }
}
```

Here, there are some drawbacks:
- the methods CreateCustomer and CreateAdress mutate the private filed adress and customer : no information containing in the signature to be aware about the mutation
- the code in the method _Process_ is not easy to read beacuse it hides the variables/parameters used to complete the operation.  

Now the code is more readeable in the _Process_ method and also, we remove the state of the class by removing the private filed:

```cs
public class CustomerService
{  
  public void Process(string customerName, string customerAddress)
  {
    var address = CreateAddress(customerAddress);
    var customer = CreateCustomer();
    SaveCustomer();
  }

  private Address CreateAdress(string addressString)
  {
    return new Address(addressString);    
  }
  
  private Customer CreateCustomer(string name, Address address)
  {
    return new Customer(name, address);
  }
  
  private void SaveCustomer(Customer customer)
  {
    var repository = new Repository();
    repository.Save(customer);
  }
}
```
